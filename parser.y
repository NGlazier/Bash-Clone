%{
#include <stdio.h>
#include <stdarg.h>
#include "bash.h"
#include <string.h>

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

/*structure args is a linked list where each node stores an argument as a string*/
struct args {
    char *arg; //argument
    struct args *next; //linked list pointer
};

/*structure redir is a linked list where each node stores the type of redirection as an int
 and stores its associated file name as a string*/
struct redir {
   int dir; //input = 1, output = 2, error = 3, output_append = 4, error_append = 5
   char *fname; //filename
   struct redir *next; //linked list pointer
};



/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 1; //number of lines

static int synerrors = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
    int number;
	struct redir *predir;
	/*added my structure redir*/
	
}



%token EOLN PIPE INPUT
%token <number> OUTPUT OUTPUT_APPEND ERROR ERROR_APPEND //tokens for file redirection
%token <string> WORD 

%type <pcmd> line cmd
%type <predir> optredir optredirs //type for file redirection
%type <pargs> arg args //type for arguments

  

%% 	/* beginning of the parsing rules	*/
input	: lines
	|
  	;

lines	: oneline
	| oneline lines
	;

oneline : line
		{ if(synerrors == 0){
			doline($1, lines);}
			}
	  eoln
 	| eoln	/* blank line, do nothing */
	| error eoln
	/* if we got an error on the line, don't call the C program */
	;

eoln	: EOLN
		{ ++lines;
		synerrors = 0; }
	;

/*line is either a command, a pipe, and another line
   or a line is just a command */
line	: cmd PIPE line
		{  /*redirect files to PIPE, link commands together in linked list*/
			if($1 -> outfile != NULL){
				printf("ERROR multiple output redirections dectected.\n");
				synerrors++;
			}
			$1 -> outfile = "PIPE";
			if($3 -> infile != NULL){
				printf("ERROR multiple output redirections dectected.\n");
				synerrors++;
			}
		   $3 -> infile = "PIPE";
		   $1 -> nextpipe = $3;
		   $$ = $1;
		   
		}
	
  	| cmd 
		{ /*last command in linked list points at NULL*/
			$1 -> nextpipe = NULL;
			$$ = $1;

		}	
  	;

/*a command is a WORD with arguments and file redirections*/
cmd		: WORD args optredirs
		{	/*create structure command*/
			struct command *pcd;
			pcd = (struct command *) malloc(sizeof(struct command));

			/*first word in the line is the command name and the first argument*/
			pcd -> command = $1;
			pcd -> argv[0] = $1;
			int arg_count = 1;
			
			if($1[0] == '/' || ($1[0] == '.' && $1[1] == '/') || ($1[0] == '.' && $1[1] == '.' && $1[2] == '/')){
				char *p = strrchr($1, '/');
				if (p && *(p + 1)){
					pcd -> argv[0] = p+1;
				}
			}


			
			
			/*take structure linked list of arguments and use to fill the command's argument vector*/
			while($2 != NULL){
				
				pcd -> argv[arg_count] = $2 -> arg; 
				$2 = $2 -> next;
				
				/*keep track of the number of arguments*/
				arg_count++;
				
			}
			pcd -> argv[arg_count] = NULL; //last argument set to NULL
			
			/*take structure linked list of file redirections and use to fill out the command's redirection and file names*/
			while($3 != NULL){
				if($3 -> dir == 1){ //1 to represent input
					if(pcd -> outfile != NULL || pcd -> errfile != NULL){
						printf("WARNING file redirection arguments should be of the order < i 2> e > o\n");
					}
					if(pcd -> infile != NULL){
						printf("ERROR multiple input redirections dectected.\n");
						synerrors++;
					}
					pcd -> infile = $3 -> fname;
				}
				if($3 -> dir == 2){ //2 to represent output
					
					if(pcd -> outfile != NULL){
						printf("ERROR multiple output redirections dectected.\n");
						synerrors++;
					}
					pcd -> outfile = $3 -> fname;
				}
				if($3 -> dir == 3){ //3 to represent error
					if(pcd -> outfile != NULL){
						printf("WARNING file redirection arguments should be of the order < i 2> e > o\n");
					}
					if(pcd -> errfile != NULL){
						printf("ERROR multiple error redirections dectected.\n");
						synerrors++;
					}
					pcd -> errfile = $3 -> fname;
				}
				if($3 -> dir == 4){ //4 to represent output_append
				
					if(pcd -> outfile != NULL){
						
						printf("ERROR multiple output redirections dectected.\n");
						synerrors++;
					}
					pcd -> outfile = $3 -> fname;
					pcd -> output_append = '1';
				}
				if($3 -> dir == 5){ //5 to represent error_append
				if(pcd -> outfile != NULL){
						printf("WARNING file redirection arguments should be of the order < i 2> e > o\n");
					}
				if(pcd -> errfile != NULL){
					
						printf("ERROR multiple error redirections dectected.\n");
						synerrors++;
					}
					pcd -> errfile = $3 -> fname;
					pcd -> error_append = '1';
				}
				$3 = $3 -> next;
			}

			/*fill in command's argument count*/
			pcd -> argc = arg_count;
			
			/*nextpipe initialized to NULL*/
			pcd -> nextpipe = NULL;
			$$ = pcd;

		}
	;

/*arguments is either one argument followed by arguments
	or arguments is nothing*/
args	: arg args
		{ /*link argument nodes in linked list*/
			$1 -> next = $2;
		  $$ = $1; 
		}
	| 	
		{ /*last argument points to NULL*/
			$$ = NULL; }
		
	;

/*an argument is a WORD*/
arg		: WORD
		{ /*create node for argument*/
			struct args *parg;
		  parg = (struct args *) malloc(sizeof(struct args));
		  parg -> arg = $1;
		  
		  /*node points to NULL by default*/
		  parg -> next = NULL;
		  $$ = parg;	
		}
	;

/*file redirections is either one redirection followed by redirections
	or redirections is nothing*/
optredirs	: optredir optredirs
			{ /*link file redirection nodes in linked list*/
				$1 -> next = $2;
			 $$ = $1;
			}
		|
			{ /*last redirection points to NULL*/
				$$ = NULL;}
	
/*a redirection is either an INPUT and a WORD, OUTPUT and a WORD, ERROR and a WORD,
	 OUTPUT_APPEND and a WORD, or ERROR_APPEND and a WORD*/	
optredir		: INPUT WORD
				{ /*create and build file redirection node*/
					struct redir *predir;
					
		          predir = (struct redir *) malloc(sizeof(struct redir));
				  predir -> dir = 1;
				  predir -> fname = $2;

				  /*node points to NULL by default*/
				  predir -> next = NULL;
				  $$ = predir;
				}

			| OUTPUT WORD
				{/*create and build file redirection node*/
					struct redir *predir;
		          predir = (struct redir *) malloc(sizeof(struct redir));
				  predir -> dir = 2;
				  predir -> fname = $2;

				  /*node points to NULL by default*/
				  predir -> next = NULL;
				  $$ = predir;}

			| ERROR WORD
				{/*create and build file redirection node*/
					struct redir *predir;
		          predir = (struct redir *) malloc(sizeof(struct redir));
				  predir -> dir = 3;
				  predir -> fname = $2;

				  /*node points to NULL by default*/
				  predir -> next = NULL;
				  $$ = predir;}

			| OUTPUT_APPEND WORD
				{/*create and build file redirection node*/
					struct redir *predir;
		          predir = (struct redir *) malloc(sizeof(struct redir));
				  predir -> dir = 4;
				  predir -> fname = $2;

				  /*node points to NULL by default*/
				  predir -> next = NULL;
				  $$ = predir;}

			| 	ERROR_APPEND WORD
				{/*create and build file redirection node*/
					struct redir *predir;
		          predir = (struct redir *) malloc(sizeof(struct redir));
				  predir -> dir = 5;
				  predir -> fname = $2;

				  /*node points to NULL by default*/
				  predir -> next = NULL;
				  $$ = predir;}
	;

%%

void
yyerror(const char *error_string, ...)
{
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;

    fprintf(f,"Error on line %d: ", lines);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}
